#' Read user input files
#'
#' Checks technology used and dispatches call to correct reading function.
#' In case of 10x, `annot` contains a data.frame from reading the
#' features.tsv.gz file, while in rhapsody it contains the gene symbols as read
#' from the count matrix.
#'
#' @inheritParams download_user_files
#' @param prev_out list with experiment configuration settings
#'
#' @return list with 'output' slot containing \itemize{
#'   \item{"counts_list"}{named list of dgCMatrix per sample}
#'   \item{"annot"}{data.frame with gene ids and/or symbols}
#' @export
load_user_files <- function(input, pipeline_config, prev_out, input_dir = "/input") {
  message("Loading user files...")
  check_prev_out(prev_out, "config")

  # destructure previous output
  config <- prev_out$config

  technology <- ifelse(config$input$type == "rhapsody", "rhapsody", "10x")

  read_fun <- switch(technology,
    "10x" = read_10x_files,
    "rhapsody" = read_rhapsody_files
  )

  message(
    "Samples to include in the analysis:\n- ",
    paste(config$samples, collapse = "\n- ")
  )
  message("Loading ", technology, " data set from input folder.")

  user_matrices <- c(prev_out, read_fun(config, input_dir))

  res <- list(
    data = list(),
    output = user_matrices
  )

  message("\nLoading of ", technology, " files step complete.")
  return(res)
}


#' Calls Read10X
#'
#' Cellranger outputs from V2 and V3 kits were renamed to look like V3
#' (features.tsv.gz).
#'
#' @param config experiment settings.
#'
read_10x_files <- function(config, input_dir) {
  counts_list <- list()
  annot_list <- list()
  feature_types_list <- list()

  samples <- config$samples

  for (sample in samples) {
    sample_dir <- file.path(input_dir, sample)
    sample_fpaths <- list.files(sample_dir)
    annot_fpath <- file.path(sample_dir, "features.tsv.gz")
    gene_column <- 1

    message("\nSample --> ", sample)
    message(
      "Reading files from ",
      sample_dir,
      " --> ",
      paste(sample_fpaths, collapse = " - ")
    )

    annot <- read.delim(annot_fpath, header = FALSE)

    if (ncol(annot) == 1 || annot[1, 2] == "Gene Expression") {
      annot[, 2] <- annot[, 1]
    }

    feature_types <- extract_feature_types(annot)

    message("Features types is ", feature_types, "for sample ", sample)

    if (feature_types == -1) {
      annot[, c(1, 2)] <- annot[, c(2, 1)]
      gene_column <- 2
      feature_types <- 1
    }

    # Make unique the annot column 1 so it's equal to the gene names that read10X makes unique
    # Only c1 needs make.unique because we copy c2 into c1 in annot if gene_column is 2
    annot[, 1] <- make.unique(annot[, 1])

    # Equalizing number of columns in case theres no Gene Expression column
    annot <- annot[, c(1, 2)]
    colnames(annot) <- c("input", "name")

    counts <- Seurat::Read10X(sample_dir, gene.column = gene_column, unique.features = TRUE)

    if (is(counts, "list")) {
      slot <- "Gene Expression"
      # questionable: grab first slot if no slot named gene expression
      if (!slot %in% names(counts)) slot <- names(counts)[1]
      counts <- counts[[slot]]
    }

    message(
      sprintf(
        "Sample %s has %s genes and %s droplets.",
        sample, nrow(counts), ncol(counts)
      )
    )

    counts_list[[sample]] <- counts
    annot_list[[sample]] <- annot
    feature_types_list[[sample]] <- feature_types
  }

  c(counts_list, annot_list) %<-% equalize_annotation_types(annot_list, counts_list, feature_types_list, samples)
  annot <- format_annot(annot_list)

  return(list(counts_list = counts_list, annot = annot))
}

#' Calls BD rhapsody data parsing functions
#'
#' Currently we only have support for sparse expression matrices.
#'
#' @inheritParams download_user_files
#'
#' @return list containing \itemize{
#'   \item{"counts_list"}{named list of dgCMatrix per sample}
#'   \item{"annot"}{data.frame with gene symbols}
#'
read_rhapsody_files <- function(config, input_dir) {

  # if we add support for other rhapsody file types (csv matrices) we should
  # check filetypes here and dispatch accordingly.

  out <- parse_rhapsody_matrix(config, input_dir)
  return(out)
}

#' Read BD Rhapsody expression_matrix.st files
#'
#' Parses sparse count matrices generated by BD Rhapsody primary analysis.
#'
#' @inheritParams download_user_files
#' @return list containing \itemize{
#'   \item{"counts_list"}{named list of dgCMatrix per sample}
#'   \item{"annot"}{data.frame with gene symbols}
#'
parse_rhapsody_matrix <- function(config, input_dir) {
  counts_list <- list()
  annot_list <- list()

  samples <- config$samples


  for (sample in samples) {
    sample_dir <- file.path(input_dir, sample)
    sample_fpaths <- file.path(sample_dir, "expression_matrix.st")

    message("\nSample --> ", sample)
    message(
      "Reading files from ",
      sample_dir,
      " --> ",
      paste(sample_fpaths, collapse = " - ")
    )

    counts <- data.table::fread(sample_fpaths)

    # catch absent DBEC column
    adjusted_col <- ifelse(
      "DBEC_Adjusted_Molecules" %in% colnames(counts),
      "DBEC_Adjusted_Molecules",
      "RSEC_Adjusted_Molecules"
    )

    # AbSeq has a "Bioproduct" col instead of "Gene" to account for proteins
    if ("Bioproduct" %in% colnames(counts)) {
      data.table::setnames(counts, "Bioproduct", "Gene")
    }

    # The ..keep is data.table syntax to grab the keep columns
    keep <- c("Cell_Index", "Gene", adjusted_col)
    counts <- counts[, ..keep]

    # convert Cell_Index to string! we parse strings from jsons a lot, and
    # having ints alone breaks things, as they are coerced to numbers
    counts[, Cell_Index := paste0("cell_", Cell_Index)]

    # clean AbSeq names, removing symbols
    counts[, Gene := gsub("[\\|:]", "_", Gene)]

    # we need the genes as ints to create the sparse matrix
    counts[, Gene := factor(Gene)]
    counts[, gene_i := as.integer(Gene)]

    features <- levels(counts$Gene)
    barcodes <- unique(counts$Cell_Index)

    # to create small sparse matrix, and keep original cell indices ("barcodes")
    counts[, cell_index_j := match(Cell_Index, barcodes)]

    counts <- Matrix::sparseMatrix(
      i = counts$gene_i,
      j = counts$cell_index_j,
      x = counts[[adjusted_col]],
      dimnames = list(features, barcodes)
    )

    message(
      sprintf(
        "Sample %s has %s genes and %s wells",
        sample, nrow(counts), ncol(counts)
      )
    )

    # Rhapsody data does not have ensemblIDs, but format_annot needs 2 cols
    annot <- data.frame(input=features, name=features)

    counts_list[[sample]] <- counts
    annot_list[[sample]] <- annot
  }

  annot <- format_annot(annot_list)

  return(list(counts_list = counts_list, annot = annot))
}

format_annot <- function(annot_list) {
  annot <- unique(do.call("rbind", annot_list))
  colnames(annot) <- c("input", "name")

  message("Deduplicating gene annotations...")

  # add ENSEMBL ID for genes that are duplicated (geneNameDuplicated-ENSEMBL)
  # original name kept in 'original_name' column
  gname <- annot$name
  annot$original_name <- gname
  is.dup <- duplicated(gname) | duplicated(gname, fromLast = TRUE)

  # We need to convert the gene inputs from _ to - bc when we create the Seurat
  # object we do this, and the match would return NA values if any
  # of the inputs still has _.
  annot$input <- gsub("_", "-", annot$input)
  annot$name[is.dup] <- paste(gname[is.dup], annot$input[is.dup], sep = " - ")

  annot <- annot[!duplicated(annot$input), ]

  rownames(annot) <- annot$input
  return(annot)
}

# Fix annotations makes annotations compatible between samples with different types.
# The possible options for feature_types at this stage are 0,1,2
#  0 is SYMBOL/ SYMBOL
#  1 is IDS/SYMBOL
#  2 is IDS/IDS
equalize_annotation_types <- function(annot_list, counts_list, feature_types_list, samples) {
  if (any(feature_types_list == 2) && any(feature_types_list == 0) && !any(feature_types_list == 1)) stop("Incompatible features detected.")

  if (any(feature_types_list == 1) && (any(feature_types_list == 2) || any(feature_types_list == 0))) {
    annots_with_ids <- unique(do.call("rbind", annot_list[feature_types_list == 1]))

    annots_with_ids <- annots_with_ids[!duplicated(annots_with_ids$input), ]

    for (sample in samples) {
      if (feature_types_list[[sample]] == 0 || feature_types_list[[sample]] == 2) {
        sample_annot <- annot_list[[sample]]

        # Try to replace input column (currently symbols) in sample_annot with ids from annots_with_ids
        if (feature_types_list[[sample]] == 0) {

          matched_symbols_index <- match(sample_annot$input,annots_with_ids$name)
          is_in_annot_list <- which(sample_annot$input %in% annots_with_ids$name)

          sample_annot$input[is_in_annot_list] <- annots_with_ids$input[na.omit(matched_symbols_index)]

          #This avoids duplicates after combining with the annotated df.
          #Leads to a mismatch in genes between samples but it seems like the best solution
          sample_annot$input <- make.unique(sample_annot$input)

          #The counts have been loaded with gene symbols so we need to replace the rownames with the ids
          rownames(counts_list[[sample]]) <- sample_annot$input
        }

        # Try to replace names column (currently ids) in sample_annot with symbols from annots_with_ids
        if (feature_types_list[[sample]] == 2) {
          matched_ids_index <- match(sample_annot$input,annots_with_ids$input)
          is_in_annot_list <- which(sample_annot$input %in% annots_with_ids$input)

          sample_annot$name[is_in_annot_list] <- annots_with_ids$name[na.omit(matched_ids_index)]
        }

        annot_list[[sample]] <- sample_annot
      }
    }
  }
  return(list(counts_list=counts_list, annot_list=annot_list))
}

#' extract_feature_types
#'
#' Determines the type of an annot data frame.
#' Classifies the columns into either ensemblIds or symbols, and extracts a number that represents the combination.
#'
#' @param annot
#'
#' @return
#' -1 is SYMBOl/IDS
#' 0 is SYMBOL/ SYMBOL
#' 1 is IDS/SYMBOL
#' 2 is IDS/IDS
#'
#' @export
#' @examples
get_feature_types <- function(annot) {
  feature_types <- list()

  annot_c1 <- annot[, 1]
  is_ens <- annot_c1[substr(annot_c1, 1, 3) == "ENS"]
  feature_types[[1]] <- length(is_ens) >= length(annot_c1) - length(is_ens)

  annot_c2 <- annot[, 2]
  is_ens <- annot_c2[substr(annot_c2, 1, 3) == "ENS"]
  feature_types[[2]] <- length(is_ens) >= length(annot_c2) - length(is_ens)

  if (feature_types[[1]] == FALSE && feature_types[[2]] == TRUE) {
    return(-1)
  }

  return(feature_types[[1]] + feature_types[[2]])
}
