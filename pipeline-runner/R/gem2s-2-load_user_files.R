#' Read user input files
#'
#' Checks technology used and dispatches call to correct reading function.
#' In case of 10x, `annot` contains a data.frame from reading the
#' features.tsv.gz file, while in rhapsody it contains the gene symbols as read
#' from the count matrix.
#'
#' @inheritParams download_user_files
#' @param prev_out list with experiment configuration settings
#'
#' @return list with 'output' slot containing \itemize{
#'   \item{"counts_list"}{named list of dgCMatrix per sample}
#'   \item{"annot"}{data.frame with gene ids and/or symbols}
#' @export
load_user_files <- function(input, pipeline_config, prev_out, input_dir = "/input") {
  message("Loading user files...")
  check_prev_out(prev_out, "config")

  # destructure previous output
  config <- prev_out$config

  technology <- ifelse(config$input$type == "rhapsody", "rhapsody", "10x")

  read_fun <- switch(technology,
    "10x" = read_10x_files,
    "rhapsody" = read_rhapsody_files
  )

  message(
    "Samples to include in the analysis:\n- ",
    paste(config$samples, collapse = "\n- ")
  )
  message("Loading ", technology, " data set from input folder.")

  user_matrices <- c(prev_out, read_fun(config, input_dir))

  res <- list(
    data = list(),
    output = user_matrices
  )

  message("\nLoading of ", technology, " files step complete.")
  return(res)
}


#' Calls Read10X
#'
#' Cellranger outputs from V2 and V3 kits were renamed to look like V3
#' (features.tsv.gz).
#'
#' @param config experiment settings.
#'
read_10x_files <- function(config, input_dir) {
  counts_list <- list()
  annot_list <- list()
  feature_types_list <- list()

  samples <- config$samples

  for (sample in samples) {
    sample_dir <- file.path(input_dir, sample)
    sample_fpaths <- list.files(sample_dir)
    annot_fpath <- file.path(sample_dir, "features.tsv.gz")

    message("\nSample --> ", sample)
    message(
      "Reading files from ",
      sample_dir,
      " --> ",
      paste(sample_fpaths, collapse = " - ")
    )

    annotations <- read_10x_annotations(annot_fpath, sample)
    counts <- Seurat::Read10X(sample_dir, gene.column = annotations[["gene_column"]], unique.features = TRUE)

    if (is(counts, "list")) {
      slot <- "Gene Expression"
      # questionable: grab first slot if no slot named gene expression
      if (!slot %in% names(counts)) slot <- names(counts)[1]
      counts <- counts[[slot]]
    }

    message(
      sprintf(
        "Sample %s has %s genes and %s droplets.",
        sample, nrow(counts), ncol(counts)
      )
    )

    c(counts, annotations) %<-% filter_unnamed_features(counts, annotations, sample)

    counts_list[[sample]] <- counts
    annot_list[[sample]] <- annotations[["annot"]]
    feature_types_list[[sample]] <- annotations[["feature_types"]]
  }

  c(counts_list, annot_list) %<-% normalize_annotation_types(annot_list, counts_list, feature_types_list, samples)
  annot <- format_annot(annot_list)

  return(list(counts_list = counts_list, annot = annot))
}

#' Calls BD rhapsody data parsing functions
#'
#' Currently we only have support for sparse expression matrices.
#'
#' @inheritParams download_user_files
#'
#' @return list containing \itemize{
#'   \item{"counts_list"}{named list of dgCMatrix per sample}
#'   \item{"annot"}{data.frame with gene symbols}
#'
read_rhapsody_files <- function(config, input_dir) {

  # if we add support for other rhapsody file types (csv matrices) we should
  # check filetypes here and dispatch accordingly.

  out <- parse_rhapsody_matrix(config, input_dir)
  return(out)
}

#' Read BD Rhapsody expression_matrix.st files
#'
#' Parses sparse count matrices generated by BD Rhapsody primary analysis.
#'
#' @inheritParams download_user_files
#' @return list containing \itemize{
#'   \item{"counts_list"}{named list of dgCMatrix per sample}
#'   \item{"annot"}{data.frame with gene symbols}
#'
parse_rhapsody_matrix <- function(config, input_dir) {
  counts_list <- list()
  annot_list <- list()

  samples <- config$samples


  for (sample in samples) {
    sample_dir <- file.path(input_dir, sample)
    sample_fpaths <- file.path(sample_dir, "expression_matrix.st")

    message("\nSample --> ", sample)
    message(
      "Reading files from ",
      sample_dir,
      " --> ",
      paste(sample_fpaths, collapse = " - ")
    )

    counts <- data.table::fread(sample_fpaths)

    # catch absent DBEC column
    adjusted_col <- ifelse(
      "DBEC_Adjusted_Molecules" %in% colnames(counts),
      "DBEC_Adjusted_Molecules",
      "RSEC_Adjusted_Molecules"
    )

    # AbSeq has a "Bioproduct" col instead of "Gene" to account for proteins
    if ("Bioproduct" %in% colnames(counts)) {
      data.table::setnames(counts, "Bioproduct", "Gene")
    }

    # The ..keep is data.table syntax to grab the keep columns
    keep <- c("Cell_Index", "Gene", adjusted_col)
    counts <- counts[, ..keep]

    # convert Cell_Index to string! we parse strings from jsons a lot, and
    # having ints alone breaks things, as they are coerced to numbers
    counts[, Cell_Index := paste0("cell_", Cell_Index)]

    # clean AbSeq names, removing symbols
    counts[, Gene := gsub("[\\|:]", "_", Gene)]

    # we need the genes as ints to create the sparse matrix
    counts[, Gene := factor(Gene)]
    counts[, gene_i := as.integer(Gene)]

    features <- levels(counts$Gene)
    barcodes <- unique(counts$Cell_Index)

    # to create small sparse matrix, and keep original cell indices ("barcodes")
    counts[, cell_index_j := match(Cell_Index, barcodes)]

    counts <- Matrix::sparseMatrix(
      i = counts$gene_i,
      j = counts$cell_index_j,
      x = counts[[adjusted_col]],
      dimnames = list(features, barcodes)
    )

    message(
      sprintf(
        "Sample %s has %s genes and %s wells",
        sample, nrow(counts), ncol(counts)
      )
    )

    # Rhapsody data does not have ensemblIDs, but format_annot needs 2 cols
    annot <- data.frame(input = features, name = features)

    counts_list[[sample]] <- counts
    annot_list[[sample]] <- annot
  }

  annot <- format_annot(annot_list)

  return(list(counts_list = counts_list, annot = annot))
}

read_10x_annotations <- function(annot_fpath, sample, gene_column) {
  gene_column <- 1

  annot <- read.delim(annot_fpath, header = FALSE)

  # duplicate first col if there is only one col with gene names/ids, or
  # if there is a "Gene Expression" col
  if (ncol(annot) == 1 || annot[1, 2] == "Gene Expression") {
    annot[, 2] <- annot[, 1]
  }

  feature_types <- get_feature_types(annot)

  message("Feature types are ", feature_types, "for sample ", sample)

  # reverse annot cols if symbols are first
  if (feature_types == SYM_IDS) {
    annot[, c(1, 2)] <- annot[, c(2, 1)]
    gene_column <- 2
    feature_types <- IDS_SYM
  }

  # make same names in annot seurat makes for count matrix.
  # Only first col, we either copy or reverse order of the annot data.frame
  annot[, 1] <- make.unique(annot[, 1])

  # Equalizing number of columns in case there's no Gene Expression column
  annot <- annot[, c(1, 2)]
  colnames(annot) <- c("input", "name")

  return(list("annot" = annot, "feature_types" = feature_types, "gene_column" = gene_column))
}

format_annot <- function(annot_list) {
  annot <- unique(do.call("rbind", annot_list))
  colnames(annot) <- c("input", "name")

  message("Deduplicating gene annotations...")

  # add ENSEMBL ID for genes that are duplicated (geneNameDuplicated-ENSEMBL)
  # original name kept in 'original_name' column
  gname <- annot$name
  annot$original_name <- gname
  is.dup <- duplicated(gname) | duplicated(gname, fromLast = TRUE)

  # We need to convert the gene inputs from _ to - bc when we create the Seurat
  # object we do this, and the match would return NA values if any
  # of the inputs still has _.
  annot$input <- gsub("_", "-", annot$input)
  annot$name[is.dup] <- paste(gname[is.dup], annot$input[is.dup], sep = " - ")

  annot <- annot[!duplicated(annot$input), ]

  rownames(annot) <- annot$input
  return(annot)
}

# Fix annotations makes annotations compatible between samples with different types.
# The possible options for feature_types at this stage are 0,1,2
#  0 is SYMBOL/ SYMBOL
#  1 is IDS/SYMBOL
#  2 is IDS/IDS
normalize_annotation_types <- function(annot_list, counts_list, feature_types_list, samples) {

  if (any(feature_types_list == IDS_IDS) &&
      any(feature_types_list == SYM_SYM) &&
      !any(feature_types_list == IDS_SYM)) {
    stop("Incompatible features detected.")
  }

  if (any(feature_types_list == IDS_SYM) &&
      (any(feature_types_list == IDS_IDS) ||
       any(feature_types_list == SYM_SYM))) {

    annots_with_ids <-
      unique(do.call("rbind", annot_list[feature_types_list == IDS_SYM]))

    annots_with_ids <-
      annots_with_ids[!duplicated(annots_with_ids$input),]

    for (sample in samples) {
      if (feature_types_list[[sample]] == SYM_SYM ||
          feature_types_list[[sample]] == IDS_IDS) {
        sample_annot <- annot_list[[sample]]

        # Try to replace input column (currently symbols) in sample_annot with ids from annots_with_ids
        if (feature_types_list[[sample]] == SYM_SYM) {
          matched_symbols_index <-
            match(sample_annot$input, annots_with_ids$name)
          is_in_annot_list <-
            which(sample_annot$input %in% annots_with_ids$name)

          sample_annot$input[is_in_annot_list] <-
            annots_with_ids$input[na.omit(matched_symbols_index)]

          #This avoids duplicates after combining with the annotated df.
          #Leads to a mismatch in genes between samples but it seems like the best solution
          sample_annot$input <- make.unique(sample_annot$input)

          #The counts have been loaded with gene symbols so we need to replace the rownames with the ids
          rownames(counts_list[[sample]]) <- sample_annot$input
        }

        # Try to replace names column (currently ids) in sample_annot with symbols from annots_with_ids
        if (feature_types_list[[sample]] == IDS_IDS) {
          matched_ids_index <- match(sample_annot$input, annots_with_ids$input)
          is_in_annot_list <-
            which(sample_annot$input %in% annots_with_ids$input)

          sample_annot$name[is_in_annot_list] <-
            annots_with_ids$name[na.omit(matched_ids_index)]
        }

        annot_list[[sample]] <- sample_annot
      }
    }
  }
  return(list(counts_list=counts_list, annot_list=annot_list))
}

#' Determine the type of features in the annot data frame
#'
#' Classifies the features file columns into either ensemblIds or symbols
#'
#' @param annot data.frame read from features file
#' @return character vector indicating feature types
#'
#' @export
get_feature_types <- function(annot) {
  is_ens_col1 <- startsWith(annot[[1]], "ENS")
  pct_ens_col1 <- sum(is_ens_col1) / nrow(annot)

  is_ens_col2 <- startsWith(annot[[2]], "ENS")
  pct_ens_col2 <- sum(is_ens_col2) / nrow(annot)

  is_ens <- c(pct_ens_col1 >= 0.5, pct_ens_col2 >= 0.5)

  # reverse case, sym in first and id in second column
  if (!is_ens[1] && is_ens[2]) return(SYM_IDS)

  # regular cases. sum of booleans returns ints. convert to char to string match
  feature_type <- switch(as.character(sum(is_ens)),
                         "0" = SYM_SYM,
                         "1" = IDS_SYM,
                         "2" = IDS_IDS)

  return(feature_type)
}

filter_unnamed_features <- function(counts, annotations, sample) {

  # Check existence of empty gene symbols in count matrix' rownames.
  # If there are more than one the first will be empty, while the
  # following will be ".1", ".2"... because Seurat runs make.unique
  unnamed_genes <- c(which(rownames(counts) == ""), grep("^\\.[0-9]+", rownames(counts)))


  # remove rows with empty names if < 0.1% of the total features.
  if (length(unnamed_genes) != 0 & length(unnamed_genes) / nrow(counts) < 0.001) {
    counts <- counts[-unnamed_genes,]
    message(
      sprintf(
        "Removed %s rows with empty gene symbol from count matrix of sample %s",
        length(unnamed_genes), sample
      )
    )
  }

  # Check if there are any rows with empty gene symbol in the features file
  # and remove them if < 0.1% of the total number of features
  unnamed_ids <- which(annotations[["annot"]][,1] == "")


  if (length(unnamed_ids) != 0 & length(unnamed_ids) / nrow(annotations[["annot"]]) < 0.001) {
    annotations[["annot"]] <- annotations[["annot"]][-unnamed_ids,]
    message(
      sprintf(
        "Removed %s rows with empty gene symbol from annotations table of sample %s",
        length(unnamed_ids), sample
      )
    )
  }


  return(list("counts" = counts, "annotations" = annotations))

}
